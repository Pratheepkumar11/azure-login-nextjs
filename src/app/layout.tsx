import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import { redirect } from "next/navigation";
import { getCookie } from "@/core";
import { headers } from "next/headers";

const X_URL = 'x-url';
const REFERER = 'referer';
const HOST = 'host';
const DEFAULT_URL = 'http://localhost:3000';
const DOMAIN = '{domain}';
const URL = '{url}';
const AZURE_TOKEN = 'azureToken';
const ERROR_CODE = 'error';
const UNAUTHORIZED = 'unauthorized';

const extractCurrentUrlFromHeaders = (headersList: Headers): URL => {
  const xUrl = headersList.get(X_URL);
  const referer = headersList.get(REFERER);
  const fullUrl = xUrl ?? referer ?? '';
  return new globalThis.URL(fullUrl || DEFAULT_URL);
};

const extractDomainFromRequestHeaders = (headersList: Headers): string => headersList.get(REFERER) || headersList.get(HOST) || '';

const constructAzureLoginUrl = (domain: string): string => {
  const url = `/`;
  const loginApiUrl = process.env.AZURE_LOGIN_API_URL;

  if (!loginApiUrl) {
    return '';
  }

  if (!domain) {
    return `/api/azure/login?returnUrl=${url}`;
  }

  return loginApiUrl.replace(DOMAIN, domain).replace(URL, url);
};

const isUserUnauthenticatedInEmbargo = (isEmbargo: boolean): boolean => isEmbargo && getCookie(AZURE_TOKEN) === undefined;

export const validateUserAuthenticationAndRedirect = async (
  isEmbargo: boolean,
) => {
  const headersList = await headers();
  const url = extractCurrentUrlFromHeaders(headersList);
  const errorParam = url.searchParams.get(ERROR_CODE) || '';

  if (errorParam !== UNAUTHORIZED) {
    const domain = extractDomainFromRequestHeaders(headersList);

    if (isUserUnauthenticatedInEmbargo(isEmbargo)) {
      const loginUrl = constructAzureLoginUrl(domain);
      redirect(loginUrl);
    }
  }
};

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default async function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {

  await validateUserAuthenticationAndRedirect(true);
  
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        {children}
      </body>
    </html>
  );
}
